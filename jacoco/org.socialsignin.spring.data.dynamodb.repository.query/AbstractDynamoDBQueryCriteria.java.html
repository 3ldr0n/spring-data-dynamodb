<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDynamoDBQueryCriteria.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Spring Data DynamoDB</a> &gt; <a href="index.source.html" class="el_package">org.socialsignin.spring.data.dynamodb.repository.query</a> &gt; <span class="el_source">AbstractDynamoDBQueryCriteria.java</span></div><h1>AbstractDynamoDBQueryCriteria.java</h1><pre class="source lang-java linenums">/**
 * Copyright Â© 2018 spring-data-dynamodb (https://github.com/derjust/spring-data-dynamodb)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.socialsignin.spring.data.dynamodb.repository.query;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperFieldModel;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperTableModel;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMarshaller;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBQueryExpression;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTypeConverter;
import com.amazonaws.services.dynamodbv2.model.AttributeValue;
import com.amazonaws.services.dynamodbv2.model.ComparisonOperator;
import com.amazonaws.services.dynamodbv2.model.Condition;
import com.amazonaws.services.dynamodbv2.model.QueryRequest;
import com.amazonaws.services.dynamodbv2.model.Select;
import org.socialsignin.spring.data.dynamodb.core.DynamoDBOperations;
import org.socialsignin.spring.data.dynamodb.marshaller.Date2IsoDynamoDBMarshaller;
import org.socialsignin.spring.data.dynamodb.marshaller.Instant2IsoDynamoDBMarshaller;
import org.socialsignin.spring.data.dynamodb.query.Query;
import org.socialsignin.spring.data.dynamodb.repository.support.DynamoDBEntityInformation;
import org.socialsignin.spring.data.dynamodb.utils.SortHandler;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;

/**
 * @author Michael Lavelle
 * @author Sebastian Just
 */
public abstract class AbstractDynamoDBQueryCriteria&lt;T, ID&gt; implements DynamoDBQueryCriteria&lt;T, ID&gt;, SortHandler {

	protected Class&lt;T&gt; clazz;
	private DynamoDBEntityInformation&lt;T, ID&gt; entityInformation;
	private Map&lt;String, String&gt; attributeNamesByPropertyName;
	private final DynamoDBMapperTableModel&lt;T&gt; tableModel;
	private String hashKeyPropertyName;

	protected MultiValueMap&lt;String, Condition&gt; attributeConditions;
	protected MultiValueMap&lt;String, Condition&gt; propertyConditions;

	protected Object hashKeyAttributeValue;
	protected Object hashKeyPropertyValue;
	protected String globalSecondaryIndexName;
<span class="fc" id="L73">	protected Sort sort = Sort.unsorted();</span>
<span class="fc" id="L74">	protected Optional&lt;String&gt; projection = Optional.empty();</span>

	public abstract boolean isApplicableForLoad();

	protected QueryRequest buildQueryRequest(String tableName, String theIndexName, String hashKeyAttributeName,
			String rangeKeyAttributeName, String rangeKeyPropertyName, List&lt;Condition&gt; hashKeyConditions,
			List&lt;Condition&gt; rangeKeyConditions) {

		// TODO Set other query request properties based on config
<span class="fc" id="L83">		QueryRequest queryRequest = new QueryRequest();</span>
<span class="fc" id="L84">		queryRequest.setTableName(tableName);</span>
<span class="fc" id="L85">		queryRequest.setIndexName(theIndexName);</span>

<span class="pc bpc" id="L87" title="1 of 2 branches missed.">		if (isApplicableForGlobalSecondaryIndex()) {</span>
<span class="fc" id="L88">			List&lt;String&gt; allowedSortProperties = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L90" title="All 2 branches covered.">			for (Entry&lt;String, List&lt;Condition&gt;&gt; singlePropertyCondition : propertyConditions.entrySet()) {</span>
<span class="fc" id="L91">				if (entityInformation.getGlobalSecondaryIndexNamesByPropertyName().keySet()</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">						.contains(singlePropertyCondition.getKey())) {</span>
<span class="fc" id="L93">					allowedSortProperties.add(singlePropertyCondition.getKey());</span>
				}
<span class="fc" id="L95">			}</span>

<span class="fc" id="L97">			HashMap&lt;String, Condition&gt; keyConditions = new HashMap&lt;&gt;();</span>

<span class="pc bpc" id="L99" title="1 of 4 branches missed.">			if (hashKeyConditions != null &amp;&amp; hashKeyConditions.size() &gt; 0) {</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">				for (Condition hashKeyCondition : hashKeyConditions) {</span>
<span class="fc" id="L101">					keyConditions.put(hashKeyAttributeName, hashKeyCondition);</span>
<span class="fc" id="L102">					allowedSortProperties.add(hashKeyPropertyName);</span>
<span class="fc" id="L103">				}</span>
			}
<span class="pc bpc" id="L105" title="1 of 4 branches missed.">			if (rangeKeyConditions != null &amp;&amp; rangeKeyConditions.size() &gt; 0) {</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">				for (Condition rangeKeyCondition : rangeKeyConditions) {</span>
<span class="fc" id="L107">					keyConditions.put(rangeKeyAttributeName, rangeKeyCondition);</span>
<span class="fc" id="L108">					allowedSortProperties.add(rangeKeyPropertyName);</span>
<span class="fc" id="L109">				}</span>
			}

<span class="fc bfc" id="L112" title="All 2 branches covered.">			for (Entry&lt;String, List&lt;Condition&gt;&gt; singleAttributeConditions : attributeConditions.entrySet()) {</span>

<span class="fc bfc" id="L114" title="All 2 branches covered.">				for (Condition condition : singleAttributeConditions.getValue()) {</span>
<span class="fc" id="L115">					keyConditions.put(singleAttributeConditions.getKey(), condition);</span>
<span class="fc" id="L116">				}</span>
<span class="fc" id="L117">			}</span>

<span class="fc bfc" id="L119" title="All 2 branches covered.">			for (Order order : sort) {</span>
<span class="fc" id="L120">				final String sortProperty = order.getProperty();</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">				if (entityInformation.isGlobalIndexRangeKeyProperty(sortProperty)) {</span>
<span class="nc" id="L122">					allowedSortProperties.add(sortProperty);</span>
				}
<span class="fc" id="L124">			}</span>

<span class="fc" id="L126">			queryRequest.setKeyConditions(keyConditions);</span>
			// Might be overwritten in the actual Query classes
<span class="fc bfc" id="L128" title="All 2 branches covered.">			if (projection.isPresent()) {</span>
<span class="fc" id="L129">				queryRequest.setSelect(Select.SPECIFIC_ATTRIBUTES);</span>
<span class="fc" id="L130">				queryRequest.setProjectionExpression(projection.get());</span>
			} else {
<span class="fc" id="L132">				queryRequest.setSelect(Select.ALL_PROJECTED_ATTRIBUTES);</span>
			}

<span class="fc" id="L135">			applySortIfSpecified(queryRequest, new ArrayList&lt;&gt;(new HashSet&lt;&gt;(allowedSortProperties)));</span>
		}
<span class="fc" id="L137">		return queryRequest;</span>
	}

	protected void applySortIfSpecified(DynamoDBQueryExpression&lt;T&gt; queryExpression,
			List&lt;String&gt; permittedPropertyNames) {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">		if (permittedPropertyNames.size() &gt; 1) {</span>
<span class="nc" id="L143">			throw new UnsupportedOperationException(&quot;Can only sort by at most a single range or index range key&quot;);</span>

		}

<span class="fc" id="L147">		boolean sortAlreadySet = false;</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">		for (Order order : sort) {</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">			if (permittedPropertyNames.contains(order.getProperty())) {</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">				if (sortAlreadySet) {</span>
<span class="nc" id="L151">					throw new UnsupportedOperationException(&quot;Sorting by multiple attributes not possible&quot;);</span>

				}
<span class="fc" id="L154">				queryExpression.setScanIndexForward(order.getDirection().equals(Direction.ASC));</span>
<span class="fc" id="L155">				sortAlreadySet = true;</span>
			} else {
<span class="fc" id="L157">				throw new UnsupportedOperationException(</span>
						&quot;Sorting only possible by &quot; + permittedPropertyNames + &quot; for the criteria specified&quot;);
			}
<span class="fc" id="L160">		}</span>
<span class="fc" id="L161">	}</span>

	protected void applySortIfSpecified(QueryRequest queryRequest, List&lt;String&gt; permittedPropertyNames) {
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">		if (permittedPropertyNames.size() &gt; 2) {</span>
<span class="nc" id="L165">			throw new UnsupportedOperationException(&quot;Can only sort by at most a single global hash and range key&quot;);</span>
		}

<span class="fc" id="L168">		boolean sortAlreadySet = false;</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">		for (Order order : sort) {</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">			if (permittedPropertyNames.contains(order.getProperty())) {</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">				if (sortAlreadySet) {</span>
<span class="nc" id="L172">					throw new UnsupportedOperationException(&quot;Sorting by multiple attributes not possible&quot;);</span>

				}
<span class="pc bpc" id="L175" title="3 of 4 branches missed.">				if (queryRequest.getKeyConditions().size() &gt; 1 &amp;&amp; !hasIndexHashKeyEqualCondition()) {</span>
<span class="nc" id="L176">					throw new UnsupportedOperationException(</span>
							&quot;Sorting for global index queries with criteria on both hash and range not possible&quot;);

				}
<span class="fc" id="L180">				queryRequest.setScanIndexForward(order.getDirection().equals(Direction.ASC));</span>
<span class="fc" id="L181">				sortAlreadySet = true;</span>
			} else {
<span class="nc" id="L183">				throw new UnsupportedOperationException(</span>
						&quot;Sorting only possible by &quot; + permittedPropertyNames + &quot; for the criteria specified&quot;);
			}
<span class="fc" id="L186">		}</span>
<span class="fc" id="L187">	}</span>

	public boolean comparisonOperatorsPermittedForQuery() {
<span class="fc" id="L190">		List&lt;ComparisonOperator&gt; comparisonOperatorsPermittedForQuery = Arrays.asList(new ComparisonOperator[]{</span>
				ComparisonOperator.EQ, ComparisonOperator.LE, ComparisonOperator.LT, ComparisonOperator.GE,
				ComparisonOperator.GT, ComparisonOperator.BEGINS_WITH, ComparisonOperator.BETWEEN});

		// Can only query on subset of Conditions
<span class="fc bfc" id="L195" title="All 2 branches covered.">		for (Collection&lt;Condition&gt; conditions : attributeConditions.values()) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">			for (Condition condition : conditions) {</span>
<span class="fc" id="L197">				if (!comparisonOperatorsPermittedForQuery</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">						.contains(ComparisonOperator.fromValue(condition.getComparisonOperator()))) {</span>
<span class="fc" id="L199">					return false;</span>
				}
<span class="fc" id="L201">			}</span>
<span class="fc" id="L202">		}</span>
<span class="fc" id="L203">		return true;</span>
	}

	protected List&lt;Condition&gt; getHashKeyConditions() {
<span class="fc" id="L207">		List&lt;Condition&gt; hashKeyConditions = null;</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">		if (isApplicableForGlobalSecondaryIndex() &amp;&amp; entityInformation.getGlobalSecondaryIndexNamesByPropertyName()</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">				.keySet().contains(getHashKeyPropertyName())) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">			hashKeyConditions = getHashKeyAttributeValue() == null</span>
<span class="fc" id="L211">					? null</span>
<span class="fc" id="L212">					: Arrays.asList(createSingleValueCondition(getHashKeyPropertyName(), ComparisonOperator.EQ,</span>
<span class="fc" id="L213">							getHashKeyAttributeValue(), getHashKeyAttributeValue().getClass(), true));</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">			if (hashKeyConditions == null) {</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">				if (attributeConditions.containsKey(getHashKeyAttributeName())) {</span>
<span class="fc" id="L216">					hashKeyConditions = attributeConditions.get(getHashKeyAttributeName());</span>
				}

			}

		}
<span class="fc" id="L222">		return hashKeyConditions;</span>
	}

	public AbstractDynamoDBQueryCriteria(DynamoDBEntityInformation&lt;T, ID&gt; dynamoDBEntityInformation,
<span class="fc" id="L226">			final DynamoDBMapperTableModel&lt;T&gt; tableModel) {</span>
<span class="fc" id="L227">		this.clazz = dynamoDBEntityInformation.getJavaType();</span>
<span class="fc" id="L228">		this.attributeConditions = new LinkedMultiValueMap&lt;&gt;();</span>
<span class="fc" id="L229">		this.propertyConditions = new LinkedMultiValueMap&lt;&gt;();</span>
<span class="fc" id="L230">		this.hashKeyPropertyName = dynamoDBEntityInformation.getHashKeyPropertyName();</span>
<span class="fc" id="L231">		this.entityInformation = dynamoDBEntityInformation;</span>
<span class="fc" id="L232">		this.attributeNamesByPropertyName = new HashMap&lt;&gt;();</span>
		// TODO consider adding the DynamoDBMapper table model to
		// DynamoDBEntityInformation instead
<span class="fc" id="L235">		this.tableModel = tableModel;</span>
<span class="fc" id="L236">	}</span>

	private String getFirstDeclaredIndexNameForAttribute(Map&lt;String, String[]&gt; indexNamesByAttributeName,
			List&lt;String&gt; indexNamesToCheck, String attributeName) {
<span class="fc" id="L240">		String indexName = null;</span>
<span class="fc" id="L241">		String[] declaredOrderedIndexNamesForAttribute = indexNamesByAttributeName.get(attributeName);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">		for (String declaredOrderedIndexNameForAttribute : declaredOrderedIndexNamesForAttribute) {</span>
<span class="pc bpc" id="L243" title="1 of 4 branches missed.">			if (indexName == null &amp;&amp; indexNamesToCheck.contains(declaredOrderedIndexNameForAttribute)) {</span>
<span class="fc" id="L244">				indexName = declaredOrderedIndexNameForAttribute;</span>
			}
		}

<span class="fc" id="L248">		return indexName;</span>
	}

	protected String getGlobalSecondaryIndexName() {

		// Lazy evaluate the globalSecondaryIndexName if not already set

		// We must have attribute conditions specified in order to use a global
		// secondary index, otherwise return null for index name
		// Also this method only evaluates the
<span class="pc bpc" id="L258" title="1 of 6 branches missed.">		if (globalSecondaryIndexName == null &amp;&amp; attributeConditions != null &amp;&amp; !attributeConditions.isEmpty()) {</span>
			// Declare map of index names by attribute name which we will populate below -
			// this will be used to determine which index to use if multiple indexes are
			// applicable
<span class="fc" id="L262">			Map&lt;String, String[]&gt; indexNamesByAttributeName = new HashMap&lt;&gt;();</span>

			// Declare map of attribute lists by index name which we will populate below -
			// this will be used to determine whether we have an exact match index for
			// specified attribute conditions
<span class="fc" id="L267">			MultiValueMap&lt;String, String&gt; attributeListsByIndexName = new LinkedMultiValueMap&lt;&gt;();</span>

			// Populate the above maps
<span class="fc bfc" id="L270" title="All 2 branches covered.">			for (Entry&lt;String, String[]&gt; indexNamesForPropertyNameEntry : entityInformation</span>
<span class="fc" id="L271">					.getGlobalSecondaryIndexNamesByPropertyName().entrySet()) {</span>
<span class="fc" id="L272">				String propertyName = indexNamesForPropertyNameEntry.getKey();</span>
<span class="fc" id="L273">				String attributeName = getAttributeName(propertyName);</span>
<span class="fc" id="L274">				indexNamesByAttributeName.put(attributeName, indexNamesForPropertyNameEntry.getValue());</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">				for (String indexNameForPropertyName : indexNamesForPropertyNameEntry.getValue()) {</span>
<span class="fc" id="L276">					attributeListsByIndexName.add(indexNameForPropertyName, attributeName);</span>
				}
<span class="fc" id="L278">			}</span>

			// Declare lists to store matching index names
<span class="fc" id="L281">			List&lt;String&gt; exactMatchIndexNames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L282">			List&lt;String&gt; partialMatchIndexNames = new ArrayList&lt;&gt;();</span>

			// Populate matching index name lists - an index is either an exact match ( the
			// index attributes match all the specified criteria exactly)
			// or a partial match ( the properties for the specified criteria are contained
			// within the property set for an index )
<span class="fc bfc" id="L288" title="All 2 branches covered.">			for (Entry&lt;String, List&lt;String&gt;&gt; attributeListForIndexNameEntry : attributeListsByIndexName.entrySet()) {</span>
<span class="fc" id="L289">				String indexNameForAttributeList = attributeListForIndexNameEntry.getKey();</span>
<span class="fc" id="L290">				List&lt;String&gt; attributeList = attributeListForIndexNameEntry.getValue();</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">				if (attributeList.containsAll(attributeConditions.keySet())) {</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">					if (attributeConditions.keySet().containsAll(attributeList)) {</span>
<span class="fc" id="L293">						exactMatchIndexNames.add(indexNameForAttributeList);</span>
					} else {
<span class="fc" id="L295">						partialMatchIndexNames.add(indexNameForAttributeList);</span>
					}
				}
<span class="fc" id="L298">			}</span>

<span class="pc bpc" id="L300" title="1 of 2 branches missed.">			if (exactMatchIndexNames.size() &gt; 1) {</span>
<span class="nc" id="L301">				throw new RuntimeException(</span>
<span class="nc" id="L302">						&quot;Multiple indexes defined on same attribute set:&quot; + attributeConditions.keySet());</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">			} else if (exactMatchIndexNames.size() == 1) {</span>
<span class="fc" id="L304">				globalSecondaryIndexName = exactMatchIndexNames.get(0);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">			} else if (partialMatchIndexNames.size() &gt; 1) {</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">				if (attributeConditions.size() == 1) {</span>
<span class="fc" id="L307">					globalSecondaryIndexName = getFirstDeclaredIndexNameForAttribute(indexNamesByAttributeName,</span>
<span class="fc" id="L308">							partialMatchIndexNames, attributeConditions.keySet().iterator().next());</span>
				}
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">				if (globalSecondaryIndexName == null) {</span>
<span class="nc" id="L311">					globalSecondaryIndexName = partialMatchIndexNames.get(0);</span>
				}
<span class="fc bfc" id="L313" title="All 2 branches covered.">			} else if (partialMatchIndexNames.size() == 1) {</span>
<span class="fc" id="L314">				globalSecondaryIndexName = partialMatchIndexNames.get(0);</span>
			}
		}
<span class="fc" id="L317">		return globalSecondaryIndexName;</span>
	}
	protected boolean isHashKeyProperty(String propertyName) {
<span class="fc" id="L320">		return hashKeyPropertyName.equals(propertyName);</span>
	}

	protected String getHashKeyPropertyName() {
<span class="fc" id="L324">		return hashKeyPropertyName;</span>
	}

	protected String getHashKeyAttributeName() {
<span class="fc" id="L328">		return getAttributeName(getHashKeyPropertyName());</span>
	}

	protected boolean hasIndexHashKeyEqualCondition() {
<span class="fc" id="L332">		boolean hasIndexHashKeyEqualCondition = false;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">		for (Map.Entry&lt;String, List&lt;Condition&gt;&gt; propertyConditionList : propertyConditions.entrySet()) {</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">			if (entityInformation.isGlobalIndexHashKeyProperty(propertyConditionList.getKey())) {</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">				for (Condition condition : propertyConditionList.getValue()) {</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">					if (condition.getComparisonOperator().equals(ComparisonOperator.EQ.name())) {</span>
<span class="fc" id="L337">						hasIndexHashKeyEqualCondition = true;</span>
					}
<span class="fc" id="L339">				}</span>
			}
<span class="fc" id="L341">		}</span>
<span class="fc bfc" id="L342" title="All 4 branches covered.">		if (hashKeyAttributeValue != null &amp;&amp; entityInformation.isGlobalIndexHashKeyProperty(hashKeyPropertyName)) {</span>
<span class="fc" id="L343">			hasIndexHashKeyEqualCondition = true;</span>
		}
<span class="fc" id="L345">		return hasIndexHashKeyEqualCondition;</span>
	}

	protected boolean hasIndexRangeKeyCondition() {
<span class="fc" id="L349">		boolean hasIndexRangeKeyCondition = false;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">		for (Map.Entry&lt;String, List&lt;Condition&gt;&gt; propertyConditionList : propertyConditions.entrySet()) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">			if (entityInformation.isGlobalIndexRangeKeyProperty(propertyConditionList.getKey())) {</span>
<span class="fc" id="L352">				hasIndexRangeKeyCondition = true;</span>
			}
<span class="fc" id="L354">		}</span>
<span class="fc bfc" id="L355" title="All 4 branches covered.">		if (hashKeyAttributeValue != null &amp;&amp; entityInformation.isGlobalIndexRangeKeyProperty(hashKeyPropertyName)) {</span>
<span class="fc" id="L356">			hasIndexRangeKeyCondition = true;</span>
		}
<span class="fc" id="L358">		return hasIndexRangeKeyCondition;</span>
	}
	protected boolean isApplicableForGlobalSecondaryIndex() {
<span class="fc bfc" id="L361" title="All 2 branches covered.">		boolean global = this.getGlobalSecondaryIndexName() != null;</span>
<span class="fc bfc" id="L362" title="All 4 branches covered.">		if (global &amp;&amp; getHashKeyAttributeValue() != null &amp;&amp; !entityInformation</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">				.getGlobalSecondaryIndexNamesByPropertyName().keySet().contains(getHashKeyPropertyName())) {</span>
<span class="nc" id="L364">			return false;</span>
		}

<span class="fc" id="L367">		int attributeConditionCount = attributeConditions.keySet().size();</span>
<span class="pc bpc" id="L368" title="1 of 6 branches missed.">		boolean attributeConditionsAppropriate = hasIndexHashKeyEqualCondition()</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">				&amp;&amp; (attributeConditionCount == 1 || (attributeConditionCount == 2 &amp;&amp; hasIndexRangeKeyCondition()));</span>
<span class="pc bpc" id="L370" title="1 of 6 branches missed.">		return global &amp;&amp; (attributeConditionCount == 0 || attributeConditionsAppropriate)</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">				&amp;&amp; comparisonOperatorsPermittedForQuery();</span>

	}

	public DynamoDBQueryCriteria&lt;T, ID&gt; withHashKeyEquals(Object value) {
<span class="fc" id="L376">		Assert.notNull(value, &quot;Creating conditions on null hash keys not supported: please specify a value for '&quot;</span>
<span class="fc" id="L377">				+ getHashKeyPropertyName() + &quot;'&quot;);</span>

<span class="fc" id="L379">		hashKeyAttributeValue = getPropertyAttributeValue(getHashKeyPropertyName(), value);</span>
<span class="fc" id="L380">		hashKeyPropertyValue = value;</span>
<span class="fc" id="L381">		return this;</span>
	}

	public boolean isHashKeySpecified() {
<span class="fc bfc" id="L385" title="All 2 branches covered.">		return getHashKeyAttributeValue() != null;</span>
	}

	public Object getHashKeyAttributeValue() {
<span class="fc" id="L389">		return hashKeyAttributeValue;</span>
	}

	public Object getHashKeyPropertyValue() {
<span class="fc" id="L393">		return hashKeyPropertyValue;</span>
	}

	protected String getAttributeName(String propertyName) {
<span class="fc" id="L397">		String attributeName = attributeNamesByPropertyName.get(propertyName);</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">		if (attributeName == null) {</span>
<span class="fc" id="L399">			attributeName = entityInformation.getOverriddenAttributeName(propertyName).orElse(propertyName);</span>
<span class="fc" id="L400">			attributeNamesByPropertyName.put(propertyName, attributeName);</span>
		}
<span class="fc" id="L402">		return attributeName;</span>

	}

	@Override
	public DynamoDBQueryCriteria&lt;T, ID&gt; withPropertyBetween(String propertyName, Object value1, Object value2,
			Class&lt;?&gt; type) {
<span class="fc" id="L409">		Condition condition = createCollectionCondition(propertyName, ComparisonOperator.BETWEEN,</span>
<span class="fc" id="L410">				Arrays.asList(value1, value2), type);</span>
<span class="fc" id="L411">		return withCondition(propertyName, condition);</span>
	}

	@Override
	public DynamoDBQueryCriteria&lt;T, ID&gt; withPropertyIn(String propertyName, Iterable&lt;?&gt; value, Class&lt;?&gt; propertyType) {

<span class="fc" id="L417">		Condition condition = createCollectionCondition(propertyName, ComparisonOperator.IN, value, propertyType);</span>
<span class="fc" id="L418">		return withCondition(propertyName, condition);</span>
	}

	@Override
	public DynamoDBQueryCriteria&lt;T, ID&gt; withSingleValueCriteria(String propertyName,
			ComparisonOperator comparisonOperator, Object value, Class&lt;?&gt; propertyType) {
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">		if (comparisonOperator.equals(ComparisonOperator.EQ)) {</span>
<span class="nc" id="L425">			return withPropertyEquals(propertyName, value, propertyType);</span>
		} else {
<span class="fc" id="L427">			Condition condition = createSingleValueCondition(propertyName, comparisonOperator, value, propertyType,</span>
					false);
<span class="fc" id="L429">			return withCondition(propertyName, condition);</span>
		}
	}

	@Override
	public Query&lt;T&gt; buildQuery(DynamoDBOperations dynamoDBOperations) {
<span class="fc bfc" id="L435" title="All 2 branches covered.">		if (isApplicableForLoad()) {</span>
<span class="fc" id="L436">			return buildSingleEntityLoadQuery(dynamoDBOperations);</span>
		} else {
<span class="fc" id="L438">			return buildFinderQuery(dynamoDBOperations);</span>
		}
	}

	@Override
	public Query&lt;Long&gt; buildCountQuery(DynamoDBOperations dynamoDBOperations, boolean pageQuery) {
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">		if (isApplicableForLoad()) {</span>
<span class="nc" id="L445">			return buildSingleEntityCountQuery(dynamoDBOperations);</span>
		} else {
<span class="fc" id="L447">			return buildFinderCountQuery(dynamoDBOperations, pageQuery);</span>
		}
	}

	protected abstract Query&lt;T&gt; buildSingleEntityLoadQuery(DynamoDBOperations dynamoDBOperations);

	protected abstract Query&lt;Long&gt; buildSingleEntityCountQuery(DynamoDBOperations dynamoDBOperations);

	protected abstract Query&lt;T&gt; buildFinderQuery(DynamoDBOperations dynamoDBOperations);

	protected abstract Query&lt;Long&gt; buildFinderCountQuery(DynamoDBOperations dynamoDBOperations, boolean pageQuery);

	protected abstract boolean isOnlyHashKeySpecified();

	@Override
	public DynamoDBQueryCriteria&lt;T, ID&gt; withNoValuedCriteria(String propertyName,
			ComparisonOperator comparisonOperator) {
<span class="nc" id="L464">		Condition condition = createNoValueCondition(propertyName, comparisonOperator);</span>
<span class="nc" id="L465">		return withCondition(propertyName, condition);</span>

	}

	public DynamoDBQueryCriteria&lt;T, ID&gt; withCondition(String propertyName, Condition condition) {
<span class="fc" id="L470">		attributeConditions.add(getAttributeName(propertyName), condition);</span>
<span class="fc" id="L471">		propertyConditions.add(propertyName, condition);</span>

<span class="fc" id="L473">		return this;</span>
	}

	@SuppressWarnings({&quot;deprecation&quot;, &quot;unchecked&quot;})
	protected &lt;V extends Object&gt; Object getPropertyAttributeValue(final String propertyName, final V value) {
		// TODO consider removing DynamoDBMarshaller code altogether as table model will
		// handle accordingly
<span class="fc" id="L480">		DynamoDBTypeConverter&lt;Object, V&gt; converter = (DynamoDBTypeConverter&lt;Object, V&gt;) entityInformation</span>
<span class="fc" id="L481">				.getTypeConverterForProperty(propertyName);</span>

<span class="pc bpc" id="L483" title="1 of 2 branches missed.">		if (converter != null) {</span>
<span class="nc" id="L484">			return converter.convert(value);</span>
		}

<span class="fc" id="L487">		DynamoDBMarshaller&lt;V&gt; marshaller = (DynamoDBMarshaller&lt;V&gt;) entityInformation</span>
<span class="fc" id="L488">				.getMarshallerForProperty(propertyName);</span>

<span class="fc bfc" id="L490" title="All 2 branches covered.">		if (marshaller != null) {</span>
<span class="fc" id="L491">			return marshaller.marshall(value);</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">		} else if (tableModel != null) { // purely here for testing as DynamoDBMapperTableModel cannot be mocked using</span>
											// Mockito

<span class="fc" id="L495">			String attributeName = getAttributeName(propertyName);</span>

<span class="fc" id="L497">			DynamoDBMapperFieldModel&lt;T, Object&gt; fieldModel = tableModel.field(attributeName);</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">			if (fieldModel != null) {</span>
<span class="fc" id="L499">				return fieldModel.convert(value);</span>
			}
		}

<span class="fc" id="L503">		return value;</span>
	}

	protected &lt;V&gt; Condition createNoValueCondition(String propertyName, ComparisonOperator comparisonOperator) {

<span class="nc" id="L508">		Condition condition = new Condition().withComparisonOperator(comparisonOperator);</span>

<span class="nc" id="L510">		return condition;</span>
	}

	private List&lt;String&gt; getNumberListAsStringList(List&lt;Number&gt; numberList) {
<span class="nc" id="L514">		List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">		for (Number number : numberList) {</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">			if (number != null) {</span>
<span class="nc" id="L517">				list.add(number.toString());</span>
			} else {
<span class="nc" id="L519">				list.add(null);</span>
			}
<span class="nc" id="L521">		}</span>
<span class="nc" id="L522">		return list;</span>
	}

	@SuppressWarnings(&quot;deprecation&quot;)
	private List&lt;String&gt; getDateListAsStringList(List&lt;Date&gt; dateList) {
<span class="fc" id="L527">		DynamoDBMarshaller&lt;Date&gt; marshaller = new Date2IsoDynamoDBMarshaller();</span>
<span class="fc" id="L528">		List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">		for (Date date : dateList) {</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">			if (date != null) {</span>
<span class="fc" id="L531">				list.add(marshaller.marshall(date));</span>
			} else {
<span class="nc" id="L533">				list.add(null);</span>
			}
<span class="fc" id="L535">		}</span>
<span class="fc" id="L536">		return list;</span>
	}

	@SuppressWarnings(&quot;deprecation&quot;)
	private List&lt;String&gt; getInstantListAsStringList(List&lt;Instant&gt; dateList) {
<span class="nc" id="L541">		DynamoDBMarshaller&lt;Instant&gt; marshaller = new Instant2IsoDynamoDBMarshaller();</span>
<span class="nc" id="L542">		List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">		for (Instant date : dateList) {</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">			if (date != null) {</span>
<span class="nc" id="L545">				list.add(marshaller.marshall(date));</span>
			} else {
<span class="nc" id="L547">				list.add(null);</span>
			}
<span class="nc" id="L549">		}</span>
<span class="nc" id="L550">		return list;</span>
	}

	private List&lt;String&gt; getBooleanListAsStringList(List&lt;Boolean&gt; booleanList) {
<span class="nc" id="L554">		List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">		for (Boolean booleanValue : booleanList) {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">			if (booleanValue != null) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">				list.add(booleanValue.booleanValue() ? &quot;1&quot; : &quot;0&quot;);</span>
			} else {
<span class="nc" id="L559">				list.add(null);</span>
			}
<span class="nc" id="L561">		}</span>
<span class="nc" id="L562">		return list;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	@Nullable
	private &lt;P&gt; List&lt;P&gt; getAttributeValueAsList(@Nullable Object attributeValue) {
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">		if (attributeValue == null) {</span>
<span class="nc" id="L569">			return null;</span>
		}
<span class="fc" id="L571">		boolean isIterable = ClassUtils.isAssignable(Iterable.class, attributeValue.getClass());</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">		if (isIterable) {</span>
<span class="fc" id="L573">			List&lt;P&gt; attributeValueAsList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L574">			Iterable&lt;P&gt; iterable = (Iterable&lt;P&gt;) attributeValue;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">			for (P attributeValueElement : iterable) {</span>
<span class="fc" id="L576">				attributeValueAsList.add(attributeValueElement);</span>
<span class="fc" id="L577">			}</span>
<span class="fc" id="L578">			return attributeValueAsList;</span>
		}
<span class="fc" id="L580">		return null;</span>
	}

	protected &lt;P&gt; List&lt;AttributeValue&gt; addAttributeValue(List&lt;AttributeValue&gt; attributeValueList,
			@Nullable Object attributeValue, Class&lt;P&gt; propertyType, boolean expandCollectionValues) {
<span class="fc" id="L585">		AttributeValue attributeValueObject = new AttributeValue();</span>

<span class="fc bfc" id="L587" title="All 2 branches covered.">		if (ClassUtils.isAssignable(String.class, propertyType)) {</span>
<span class="fc" id="L588">			List&lt;String&gt; attributeValueAsList = getAttributeValueAsList(attributeValue);</span>
<span class="fc bfc" id="L589" title="All 4 branches covered.">			if (expandCollectionValues &amp;&amp; attributeValueAsList != null) {</span>
<span class="fc" id="L590">				attributeValueObject.withSS(attributeValueAsList);</span>
			} else {
<span class="fc" id="L592">				attributeValueObject.withS((String) attributeValue);</span>
			}
<span class="fc bfc" id="L594" title="All 2 branches covered.">		} else if (ClassUtils.isAssignable(Number.class, propertyType)) {</span>

<span class="fc" id="L596">			List&lt;Number&gt; attributeValueAsList = getAttributeValueAsList(attributeValue);</span>
<span class="pc bpc" id="L597" title="2 of 4 branches missed.">			if (expandCollectionValues &amp;&amp; attributeValueAsList != null) {</span>
<span class="nc" id="L598">				List&lt;String&gt; attributeValueAsStringList = getNumberListAsStringList(attributeValueAsList);</span>
<span class="nc" id="L599">				attributeValueObject.withNS(attributeValueAsStringList);</span>
<span class="nc" id="L600">			} else {</span>
<span class="fc" id="L601">				attributeValueObject.withN(attributeValue.toString());</span>
			}
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">		} else if (ClassUtils.isAssignable(Boolean.class, propertyType)) {</span>
<span class="nc" id="L604">			List&lt;Boolean&gt; attributeValueAsList = getAttributeValueAsList(attributeValue);</span>
<span class="nc bnc" id="L605" title="All 4 branches missed.">			if (expandCollectionValues &amp;&amp; attributeValueAsList != null) {</span>
<span class="nc" id="L606">				List&lt;String&gt; attributeValueAsStringList = getBooleanListAsStringList(attributeValueAsList);</span>
<span class="nc" id="L607">				attributeValueObject.withNS(attributeValueAsStringList);</span>
<span class="nc" id="L608">			} else {</span>
<span class="nc" id="L609">				boolean boolValue = ((Boolean) attributeValue).booleanValue();</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">				attributeValueObject.withN(boolValue ? &quot;1&quot; : &quot;0&quot;);</span>
			}
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">		} else if (ClassUtils.isAssignable(Date.class, propertyType)) {</span>
<span class="fc" id="L613">			List&lt;Date&gt; attributeValueAsList = getAttributeValueAsList(attributeValue);</span>
<span class="fc bfc" id="L614" title="All 4 branches covered.">			if (expandCollectionValues &amp;&amp; attributeValueAsList != null) {</span>
<span class="fc" id="L615">				List&lt;String&gt; attributeValueAsStringList = getDateListAsStringList(attributeValueAsList);</span>
<span class="fc" id="L616">				attributeValueObject.withSS(attributeValueAsStringList);</span>
<span class="fc" id="L617">			} else {</span>
<span class="fc" id="L618">				Date date = (Date) attributeValue;</span>
<span class="fc" id="L619">				String marshalledDate = new Date2IsoDynamoDBMarshaller().marshall(date);</span>
<span class="fc" id="L620">				attributeValueObject.withS(marshalledDate);</span>
			}
<span class="pc bnc" id="L622" title="All 2 branches missed.">		} else if (ClassUtils.isAssignable(Instant.class, propertyType)) {</span>
<span class="nc" id="L623">			List&lt;Instant&gt; attributeValueAsList = getAttributeValueAsList(attributeValue);</span>
<span class="nc bnc" id="L624" title="All 4 branches missed.">			if (expandCollectionValues &amp;&amp; attributeValueAsList != null) {</span>
<span class="nc" id="L625">				List&lt;String&gt; attributeValueAsStringList = getInstantListAsStringList(attributeValueAsList);</span>
<span class="nc" id="L626">				attributeValueObject.withSS(attributeValueAsStringList);</span>
<span class="nc" id="L627">			} else {</span>
<span class="nc" id="L628">				Instant date = (Instant) attributeValue;</span>
<span class="nc" id="L629">				String marshalledDate = new Instant2IsoDynamoDBMarshaller().marshall(date);</span>
<span class="nc" id="L630">				attributeValueObject.withS(marshalledDate);</span>
			}
<span class="nc" id="L632">		} else {</span>
<span class="nc" id="L633">			throw new RuntimeException(&quot;Cannot create condition for type:&quot; + attributeValue.getClass()</span>
					+ &quot; property conditions must be String,Number or Boolean, or have a DynamoDBMarshaller configured&quot;);
		}
<span class="fc" id="L636">		attributeValueList.add(attributeValueObject);</span>

<span class="fc" id="L638">		return attributeValueList;</span>
	}

	protected Condition createSingleValueCondition(String propertyName, ComparisonOperator comparisonOperator, Object o,
			Class&lt;?&gt; propertyType, boolean alreadyMarshalledIfRequired) {

<span class="fc" id="L644">		Assert.notNull(o, &quot;Creating conditions on null property values not supported: please specify a value for '&quot;</span>
				+ propertyName + &quot;'&quot;);

<span class="fc" id="L647">		List&lt;AttributeValue&gt; attributeValueList = new ArrayList&lt;&gt;(1);</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">		Object attributeValue = !alreadyMarshalledIfRequired ? getPropertyAttributeValue(propertyName, o) : o;</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">		if (ClassUtils.isAssignableValue(AttributeValue.class, attributeValue)) {</span>
<span class="fc" id="L650">			attributeValueList.add((AttributeValue) attributeValue);</span>
		} else {
<span class="fc bfc" id="L652" title="All 4 branches covered.">			boolean marshalled = !alreadyMarshalledIfRequired &amp;&amp; attributeValue != o</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">					&amp;&amp; !entityInformation.isCompositeHashAndRangeKeyProperty(propertyName);</span>

<span class="fc bfc" id="L655" title="All 2 branches covered.">			Class&lt;?&gt; targetPropertyType = marshalled ? String.class : propertyType;</span>
<span class="fc" id="L656">			addAttributeValue(attributeValueList, attributeValue, targetPropertyType, true);</span>
		}

<span class="fc" id="L659">		return new Condition().withComparisonOperator(comparisonOperator).withAttributeValueList(attributeValueList);</span>
	}

	protected Condition createCollectionCondition(String propertyName, ComparisonOperator comparisonOperator,
			Iterable&lt;?&gt; o, Class&lt;?&gt; propertyType) {

<span class="fc" id="L665">		Assert.notNull(o, &quot;Creating conditions on null property values not supported: please specify a value for '&quot;</span>
				+ propertyName + &quot;'&quot;);
<span class="fc" id="L667">		List&lt;AttributeValue&gt; attributeValueList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L668">		boolean marshalled = false;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">		for (Object object : o) {</span>
<span class="fc" id="L670">			Object attributeValue = getPropertyAttributeValue(propertyName, object);</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">			if (ClassUtils.isAssignableValue(AttributeValue.class, attributeValue)) {</span>
<span class="fc" id="L672">				attributeValueList.add((AttributeValue) attributeValue);</span>
			} else {
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">				if (attributeValue != null) {</span>
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">					marshalled = attributeValue != object</span>
<span class="pc bnc" id="L676" title="All 2 branches missed.">							&amp;&amp; !entityInformation.isCompositeHashAndRangeKeyProperty(propertyName);</span>
				}
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">				Class&lt;?&gt; targetPropertyType = marshalled ? String.class : propertyType;</span>
<span class="fc" id="L679">				addAttributeValue(attributeValueList, attributeValue, targetPropertyType, false);</span>
			}
<span class="fc" id="L681">		}</span>

<span class="fc" id="L683">		return new Condition().withComparisonOperator(comparisonOperator).withAttributeValueList(attributeValueList);</span>

	}

	@Override
	public DynamoDBQueryCriteria&lt;T, ID&gt; withSort(Sort sort) {
<span class="fc" id="L689">		this.sort = sort;</span>
<span class="fc" id="L690">		return this;</span>
	}

	@Override
	public DynamoDBQueryCriteria&lt;T, ID&gt; withProjection(Optional&lt;String&gt; projection) {
<span class="fc" id="L695">		this.projection = projection;</span>
<span class="fc" id="L696">		return this;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>